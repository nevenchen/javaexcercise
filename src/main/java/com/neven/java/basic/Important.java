package com.neven.java.basic;

import org.junit.Test;

public class Important {

	/**
	 * 条件表达式结果类型的规则： （1） 如果第二个和第三个操作数具有相同的类型，那么它就是条件表达式的类型。 （2）
	 * 如果一个操作的类型是T，T表示byte
	 * 、short或char，而另一个操作数是一个int类型的“字面常量”，并且它的值可以用类型T表示，那条件表达式的类型就是T。 （3）
	 * 否则，将对操作数类型进行提升，而条件表达式的类型就是第二个和第三个操作被提升之后的类型。
	 * 
	 * 现来使用以上规则解上面的迷题，第一个表达式符合第二条规则：一个操作数的类型是char，另一个的类型是字面常量为0的int型，但0可以表示成char
	 * ，所以最终返回类型以char类型为准；第二个表达式符合第三条规则：因为i为int型变量，而x又为char型变量，所以会先将x提升至int型，
	 * 所以最后的结果类型为int型
	 * 
	 */
	@Test
	@SuppressWarnings("unused")
	public void ifElseTest() {
		char x = 'X';
		int i = 0;
		System.out.println(true ? x : 0);// X
		System.out.println(false ? i : x);// 88

		final int j = 0;
		/*
		 * 但如果将i定义成final时，则返回结果类型为char，则此时符合第二条规则，因为final类型的变量在编译时就使用“字面常量0”
		 * 来替换三元表达式了：
		 */
		System.out.println(false ? j : x);
	}

	/**
	 * x+=i与x=x+i等效吗，许多程序员都会认为第一个表达式x+=i只是第二个表达式x=x+i的简写方式，但这并不准确。
	 * 
	 * Java语言规范中提到：复合赋值 E1 op= E2等价于简单赋值 E1 = (T)((E1) op (E2))，其中T是E1的类型。
	 * 
	 * 复合赋值表达式自动地将所执行计算的结果转型为其左侧变量的类型。如果结果的类型与该变量的类型相同，那么这个转型不会造成任何影响，然而，
	 * 如果结果的类型比该变量的类型要宽，那么复合赋值操作符将悄悄地执行一个窄化原生类型转换，这样就会导致结果不正确： short x=0; int i
	 * = 123456; x +=i; System.out.println(x);//-7616
	 * 
	 * 使用简单的赋值方式就不会有这样的问题了，因为宽类型不能自动转换成窄的类型，编译器会报错，这时我们就会注意到错误：x = x + i;//编译通不过
	 * 
	 * 请不要将复合赋值操作符作用于byte、short或char类型的变量；在将复合赋值操作符作用于int类型的变量时，要确保表达式右侧不是long、
	 * float或double类型
	 * ；在将复合赋值操作符作用于float类型的变量时，要确保表达式右侧不是double类型。其实一句：不要将让左侧的类型窄于右侧的数字类型。
	 * 
	 * 总之，不要在short、byte或char类型的变量之上使用复合赋值操作符，因为这一过程会伴随着计算前类型的提升与计算后结果的截断，
	 * 导致最后的计算结果不正确。
	 * 
	 * 
	 */
	@Test
	public void addAndGiveTest() {
		System.out.println("++++++++++++++");
		short x = 0;
		int i = 123456;
		x += i;
		System.out.println(x);// -7616

	}

	/**
	 * 结果为什么是65535而不是-1？
	 * 
	 * 窄的整型转换成较宽的整型时符号扩展规则：如果最初的数值类型是有符号的，那么就执行符号扩展（即如果符号位为1，则扩展为1，如果为零， 则扩展为0）；
	 * 如果它是char，那么不管它将要被提升成什么类型，都执行零扩展。
	 * 
	 * 了解上面的规则后，我们再来看看迷题：因为byte是有符号的类型，所以在将byte数值-1（二进制为：11111111）提升到char时，
	 * 会发生符号位扩展
	 * ，又符号位为1，所以就补8个1，最后为16个1；然后从char到int的提升时，由于是char型提升到其他类型，所以采用零扩展而不是符号扩展
	 * ，结果int数值就成了65535。
	 * 
	 * 如果将一个char数值c转型为一个宽度更宽的类型时，只是以零来扩展，但如果清晰表达以零扩展的意图，则可以考虑使用一个位掩码： int i = c
	 * & 0xffff;//实质上等同于：int i = c ;
	 * 
	 * 如果将一个char数值c转型为一个宽度更宽的整型，并且希望有符号扩展，那么就先将char转型为一个short，它与char上个具有同样的宽度，
	 * 但是它是有符号的： int i = (short)c;
	 * 
	 * 如果将一个byte数值b转型为一个char，并且不希望有符号扩展，那么必须使用一个位掩码来限制它： char c = (char)(b &
	 * 0xff);// char c = (char) b;为有符号扩展
	 */
	@Test
	public void baseTypeExtends() {
		System.out.println((int) (char) (byte) -1);// 65535
	}

}
